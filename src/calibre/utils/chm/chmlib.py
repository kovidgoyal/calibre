# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from calibre.constants import plugins

_chmlib, chmlib_err = plugins['chmlib']

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

if chmlib_err:
    raise RuntimeError('Failed to load chmlib: '+chmlib_err)


try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

CHM_UNCOMPRESSED = _chmlib.CHM_UNCOMPRESSED
CHM_COMPRESSED = _chmlib.CHM_COMPRESSED
CHM_MAX_PATHLEN = _chmlib.CHM_MAX_PATHLEN
class chmUnitInfo(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, chmUnitInfo, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, chmUnitInfo, name)
    __repr__ = _swig_repr
    __swig_setmethods__["start"] = _chmlib.chmUnitInfo_start_set
    __swig_getmethods__["start"] = _chmlib.chmUnitInfo_start_get
    if _newclass:
        start = _swig_property(_chmlib.chmUnitInfo_start_get, _chmlib.chmUnitInfo_start_set)
    __swig_setmethods__["length"] = _chmlib.chmUnitInfo_length_set
    __swig_getmethods__["length"] = _chmlib.chmUnitInfo_length_get
    if _newclass:
        length = _swig_property(_chmlib.chmUnitInfo_length_get, _chmlib.chmUnitInfo_length_set)
    __swig_setmethods__["space"] = _chmlib.chmUnitInfo_space_set
    __swig_getmethods__["space"] = _chmlib.chmUnitInfo_space_get
    if _newclass:
        space = _swig_property(_chmlib.chmUnitInfo_space_get, _chmlib.chmUnitInfo_space_set)
    __swig_setmethods__["path"] = _chmlib.chmUnitInfo_path_set
    __swig_getmethods__["path"] = _chmlib.chmUnitInfo_path_get
    if _newclass:
        path = _swig_property(_chmlib.chmUnitInfo_path_get, _chmlib.chmUnitInfo_path_set)

    def __init__(self):
        this = _chmlib.new_chmUnitInfo()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _chmlib.delete_chmUnitInfo
    __del__ = lambda self: None
chmUnitInfo_swigregister = _chmlib.chmUnitInfo_swigregister
chmUnitInfo_swigregister(chmUnitInfo)


def chm_open(filename):
    return _chmlib.chm_open(filename)
chm_open = _chmlib.chm_open

def chm_close(h):
    return _chmlib.chm_close(h)
chm_close = _chmlib.chm_close
CHM_PARAM_MAX_BLOCKS_CACHED = _chmlib.CHM_PARAM_MAX_BLOCKS_CACHED

def chm_set_param(h, paramType, paramVal):
    return _chmlib.chm_set_param(h, paramType, paramVal)
chm_set_param = _chmlib.chm_set_param
CHM_RESOLVE_SUCCESS = _chmlib.CHM_RESOLVE_SUCCESS
CHM_RESOLVE_FAILURE = _chmlib.CHM_RESOLVE_FAILURE

def chm_resolve_object(h, objPath):
    return _chmlib.chm_resolve_object(h, objPath)
chm_resolve_object = _chmlib.chm_resolve_object

def chm_retrieve_object(h, ui, addr, len):
    return _chmlib.chm_retrieve_object(h, ui, addr, len)
chm_retrieve_object = _chmlib.chm_retrieve_object
CHM_ENUMERATE_NORMAL = _chmlib.CHM_ENUMERATE_NORMAL
CHM_ENUMERATE_META = _chmlib.CHM_ENUMERATE_META
CHM_ENUMERATE_SPECIAL = _chmlib.CHM_ENUMERATE_SPECIAL
CHM_ENUMERATE_FILES = _chmlib.CHM_ENUMERATE_FILES
CHM_ENUMERATE_DIRS = _chmlib.CHM_ENUMERATE_DIRS
CHM_ENUMERATE_ALL = _chmlib.CHM_ENUMERATE_ALL
CHM_ENUMERATOR_FAILURE = _chmlib.CHM_ENUMERATOR_FAILURE
CHM_ENUMERATOR_CONTINUE = _chmlib.CHM_ENUMERATOR_CONTINUE
CHM_ENUMERATOR_SUCCESS = _chmlib.CHM_ENUMERATOR_SUCCESS

def chm_enumerate(h, what, e, context):
    return _chmlib.chm_enumerate(h, what, e, context)
chm_enumerate = _chmlib.chm_enumerate

def chm_enumerate_dir(h, prefix, what, e, context):
    return _chmlib.chm_enumerate_dir(h, prefix, what, e, context)
chm_enumerate_dir = _chmlib.chm_enumerate_dir
# This file is compatible with both classic and new-style classes.
